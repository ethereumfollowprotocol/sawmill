import { Octokit } from '@octokit/rest';
import { AnalysisResult, ProjectConfig, ServiceConfig, AlertConfig } from '../types/config.js';
import { logger } from '../utils/logger.js';
import { DeduplicationManager } from '../utils/deduplication.js';

interface CreatedIssue {
  number: number;
  url: string;
  title: string;
  repository: string;
}

interface ExistingIssue {
  number: number;
  title: string;
  createdAt: Date;
  repository: string;
}

export class GitHubIssueManager {
  private octokit: Octokit;
  private config: AlertConfig['github'];
  private deduplicationManager: DeduplicationManager;

  constructor(githubConfig: AlertConfig['github'], deduplicationManager?: DeduplicationManager) {
    if (!githubConfig?.token) {
      throw new Error('GitHub token is required');
    }
    
    this.config = githubConfig;
    this.octokit = new Octokit({
      auth: githubConfig.token,
    });
    this.deduplicationManager = deduplicationManager || new DeduplicationManager();
  }

  private findServiceConfig(serviceName: string, projectConfig: ProjectConfig): ServiceConfig | undefined {
    return projectConfig.services?.find(service => service.name === serviceName);
  }

  private async checkForDuplicateIssues(
    owner: string,
    repo: string,
    errorPatterns: string[]
  ): Promise<ExistingIssue[]> {
    if (!this.config?.deduplicationWindow) {
      return [];
    }

    const since = new Date(Date.now() - this.config.deduplicationWindow * 60 * 60 * 1000);
    
    try {
      const { data: issues } = await this.octokit.issues.listForRepo({
        owner,
        repo,
        state: 'open',
        since: since.toISOString(),
        labels: 'sawmill-generated',
      });

      const similarIssues: ExistingIssue[] = [];
      
      for (const issue of issues) {
        // Check if any error pattern matches the issue title or body
        const issueText = `${issue.title} ${issue.body}`.toLowerCase();
        const hasMatchingPattern = errorPatterns.some(pattern => 
          issueText.includes(pattern.toLowerCase())
        );
        
        if (hasMatchingPattern) {
          similarIssues.push({
            number: issue.number,
            title: issue.title,
            createdAt: new Date(issue.created_at),
            repository: `${owner}/${repo}`,
          });
        }
      }

      return similarIssues;
    } catch (error) {
      logger.warn(`Failed to check for duplicate issues in ${owner}/${repo}`, error);
      return [];
    }
  }

  private buildIssueBody(analysis: AnalysisResult, serviceName: string, projectName: string): string {
    const timestamp = new Date().toISOString();
    const otherAffectedServices = analysis.affectedServices.filter(service => service !== serviceName);
    const hasMultipleServices = otherAffectedServices.length > 0;
    
    return `## ðŸ¤– Automated Issue Report

**Project:** ${projectName}  
**Primary Service:** ${serviceName}  
**Severity:** ${analysis.severity.toUpperCase()}  
**Generated:** ${timestamp}
${hasMultipleServices ? `\n**âš ï¸ Cross-Service Impact:** This issue also affects: ${otherAffectedServices.join(', ')}` : ''}

### Summary
${analysis.summary}

### Error Patterns Detected
${analysis.errorPatterns.map(pattern => `- \`${pattern}\``).join('\n')}

### Recommendations
${analysis.recommendations.map(rec => `- ${rec}`).join('\n')}

### All Affected Services
${analysis.affectedServices.map(service => `- ${service}${service === serviceName ? ' (primary)' : ''}`).join('\n')}

${hasMultipleServices ? `\n### Multi-Service Coordination\nThis issue impacts multiple services. Consider coordinating fixes across:\n${otherAffectedServices.map(service => `- ${service}`).join('\n')}\n` : ''}

---

*This issue was automatically generated by [Sawmill](https://github.com/your-org/sawmill) based on log analysis.*

<!-- sawmill-generated: true -->
<!-- severity: ${analysis.severity} -->
<!-- service: ${serviceName} -->
<!-- project: ${projectName} -->
<!-- affected-services: ${analysis.affectedServices.join(',')} -->`;
  }

  public async createIssue(
    analysis: AnalysisResult,
    projectConfig: ProjectConfig
  ): Promise<CreatedIssue[]> {
    if (!this.config?.enabled) {
      logger.debug('GitHub issue creation is disabled');
      return [];
    }

    if (!analysis.shouldCreateIssue) {
      logger.debug('Analysis indicates no GitHub issue should be created');
      return [];
    }

    // Check severity threshold
    const severityOrder = { low: 0, medium: 1, high: 2 };
    const analysisLevel = severityOrder[analysis.severity];
    const thresholdLevel = severityOrder[this.config.createIssueThreshold];
    
    if (analysisLevel < thresholdLevel) {
      logger.debug(`Severity ${analysis.severity} below threshold ${this.config.createIssueThreshold}`);
      return [];
    }

    const createdIssues: CreatedIssue[] = [];

    // Find all services with GitHub configurations
    const servicesWithRepos = analysis.affectedServices
      .map(serviceName => ({
        serviceName,
        config: this.findServiceConfig(serviceName, projectConfig)
      }))
      .filter(({ config }) => config?.githubRepo);

    if (servicesWithRepos.length === 0) {
      logger.debug('No GitHub repositories configured for any affected services');
      return [];
    }

    // Create one issue per unique repository (not per service)
    const repoMap = new Map<string, { serviceName: string; config: ServiceConfig }>();
    
    for (const { serviceName, config } of servicesWithRepos) {
      const repoKey = `${config!.githubRepo!.owner}/${config!.githubRepo!.repo}`;
      
      // Use the first service found for each repo as the primary service
      if (!repoMap.has(repoKey)) {
        repoMap.set(repoKey, { serviceName, config: config! });
      }
    }

    // Create issues for each unique repository
    for (const [repoKey, { serviceName, config }] of repoMap) {
      const serviceConfig = config;
      const { owner, repo } = serviceConfig.githubRepo!;

      try {
        // Check Redis-based deduplication for each error pattern
        let shouldSkip = false;
        for (const errorPattern of analysis.errorPatterns) {
          const hasRecentIssue = await this.deduplicationManager.hasRecentIssue(
            projectConfig.name,
            serviceName,
            errorPattern
          );
          
          if (hasRecentIssue) {
            const issueDetails = await this.deduplicationManager.getIssueDetails(
              projectConfig.name,
              serviceName,
              errorPattern
            );
            logger.info(`Skipping issue creation for ${serviceName} - similar issue recently created: ${issueDetails?.issueUrl || 'unknown URL'}`);
            shouldSkip = true;
            break;
          }
        }
        
        if (shouldSkip) {
          continue;
        }

        // Check GitHub for duplicate issues (fallback)
        const duplicates = await this.checkForDuplicateIssues(owner, repo, analysis.errorPatterns);
        
        if (duplicates.length > 0) {
          logger.info(`Skipping issue creation for ${serviceName} - found ${duplicates.length} similar recent issues on GitHub`);
          continue;
        }

        // Create the issue
        const title = analysis.issueTitle || `${analysis.severity.toUpperCase()}: Issues detected in ${serviceName}`;
        const body = analysis.issueDescription || this.buildIssueBody(analysis, serviceName, projectConfig.name);
        
        logger.info(`Creating GitHub issue for primary service: ${serviceName} in ${owner}/${repo} (affects ${analysis.affectedServices.length} services total)`);
        
        const labels = [
          'sawmill-generated',
          `severity:${analysis.severity}`,
          ...(serviceConfig.githubRepo?.labels || [])
        ];

        const { data: issue } = await this.octokit.issues.create({
          owner,
          repo,
          title,
          body,
          labels,
          assignees: serviceConfig.githubRepo?.defaultAssignees || [],
        });

        const createdIssue: CreatedIssue = {
          number: issue.number,
          url: issue.html_url,
          title: issue.title,
          repository: `${owner}/${repo}`,
        };

        createdIssues.push(createdIssue);
        
        // Mark issue as created in Redis for deduplication
        for (const errorPattern of analysis.errorPatterns) {
          await this.deduplicationManager.markIssueCreated(
            projectConfig.name,
            serviceName,
            errorPattern,
            issue.html_url
          );
        }
        
        logger.info(`Created GitHub issue #${issue.number} for service ${serviceName} in ${owner}/${repo}`);
      } catch (error) {
        logger.error(`Failed to create GitHub issue for service ${serviceName}`, error);
        continue;
      }
    }

    return createdIssues;
  }

  public async addCommentToIssue(
    owner: string,
    repo: string,
    issueNumber: number,
    comment: string
  ): Promise<void> {
    try {
      await this.octokit.issues.createComment({
        owner,
        repo,
        issue_number: issueNumber,
        body: comment,
      });
      
      logger.info(`Added comment to issue #${issueNumber} in ${owner}/${repo}`);
    } catch (error) {
      logger.error(`Failed to add comment to issue #${issueNumber}`, error);
      throw error;
    }
  }

  public async updateIssueLabels(
    owner: string,
    repo: string,
    issueNumber: number,
    labels: string[]
  ): Promise<void> {
    try {
      await this.octokit.issues.update({
        owner,
        repo,
        issue_number: issueNumber,
        labels,
      });
      
      logger.info(`Updated labels for issue #${issueNumber} in ${owner}/${repo}`);
    } catch (error) {
      logger.error(`Failed to update labels for issue #${issueNumber}`, error);
      throw error;
    }
  }

  public async testConnection(): Promise<boolean> {
    try {
      const { data: user } = await this.octokit.users.getAuthenticated();
      logger.info(`GitHub API connection test successful for user: ${user.login}`);
      return true;
    } catch (error) {
      logger.error('GitHub API connection test failed', error);
      return false;
    }
  }

  public async validateRepositoryAccess(owner: string, repo: string): Promise<boolean> {
    try {
      await this.octokit.repos.get({ owner, repo });
      logger.debug(`Repository access validated for ${owner}/${repo}`);
      return true;
    } catch (error) {
      logger.error(`Failed to access repository ${owner}/${repo}`, error);
      return false;
    }
  }
}